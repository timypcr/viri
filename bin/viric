#!/usr/bin/env python
import sys
import os
import socket
import ssl
import http.client
import xmlrpc.client
from optparse import OptionParser

APP_DESC = 'Performs operation on remote hosts using virid'
APP_VERSION = '0.1'
DEFAULT_PORT = 6808
PROTOCOL = ssl.PROTOCOL_TLSv1

(DESCRIPTION,
PARAMETERS,
ENCODE_FILENAME) = range(3)

CMD_DEF = {
    'ls': ('Lists remote scripts or files',
        [], None),
    'get': ('Downloads a remote script or file',
        ('filename',), False),
    'put': ('Uploads a script or file to the remote host',
        ('filename',), True),
    'mv': ('Renames a file in the remote host',
        ('source', 'destination'), None),
    'rm': ('Removes a file in the remote host',
        ('filename',), False),
    'execute': ('Executes a script in the remote host',
        ('filename',), True),
}

class HTTPConnectionTLS(http.client.HTTPSConnection):
    """Extending http.client.HTTPSConnection class, so we can specify which
    protocol we want to use (we'll use TLS instead SSL)
    """
    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if self._tunnel_host:
            self.sock = sock
            self._tunnel()
        self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
            ssl_version=PROTOCOL)


class TransportTLS(xmlrpc.client.Transport):
    """Extending xmlrpc.client.Transport class, so we can specify client
    certificates needed for client authentication.
    """
    def __init__(self, key_file, cert_file, *args, **kwargs):
        self.key_file = key_file
        self.cert_file = cert_file
        super(TransportTLS, self).__init__(*args, **kwargs)

    def send_request(self, host, handler, request_body, debug):
        host, extra_headers, x509 = self.get_host_info(host)
        connection = HTTPConnectionTLS(
            host,
            None,
            self.key_file,
            self.cert_file,
            **(x509 or {}))
        if debug:
            connection.set_debuglevel(1)
        headers = {}
        if extra_headers:
            for key, val in extra_headers:
                headers[key] = val
        headers['Content-Type'] = 'text/xml'
        headers['User-Agent'] = self.user_agent
        connection.request('POST', handler, request_body, headers)
        return connection

def main(command, kwargs):
    """Handles the connection to the remote virid server, and the execution of
    remote methods. All logic is implemented on the server, so if a invalid
    command is specified, the connection will be established. This makes this
    client generic, and changes to it are rarely required.
    """
    server = xmlrpc.client.ServerProxy(
        'https://%s:%s/' % (kwargs['host'], kwargs['port']),
        transport=TransportTLS(
            kwargs['keyfile'],
            kwargs['certfile'],
            use_datetime=False))

    del kwargs['host']
    del kwargs['port']
    del kwargs['keyfile']
    del kwargs['certfile']

    if CMD_DEF[command][ENCODE_FILENAME] == True:
        with open(kwargs['filename'], 'rb') as f:
            kwargs['content'] = xmlrpc.client.Binary(f.read())
            kwargs['filename'] = os.path.split(kwargs['filename'])[1]
    elif CMD_DEF[command][ENCODE_FILENAME] == None:
        del kwargs['filename']

    if not kwargs['overwrite']:
        del kwargs['overwrite']

    return getattr(server, command)(kwargs)


if __name__ == '__main__':
    parser = OptionParser(
        'Usage: %prog command [OPTIONS]',
        description=APP_DESC,
        version=APP_VERSION)
    parser.add_option('-H', '--host', dest='host',
        help='destination host', default='localhost')
    parser.add_option('-p', '--port', dest='port',
        help='destination port', type='int', default=DEFAULT_PORT)
    parser.add_option('-k', '--keyfile', dest='keyfile',
        help='TLS key')
    parser.add_option('-c', '--certfile', dest='certfile',
        help='TLS certificate', default='keys/viric.pem')
    parser.add_option('-d', '--data', dest='data',
        help='specifies that the operation is performed for data files',
        action='store_true', default=False)
    parser.add_option('-o', '--overwrite', dest='overwrite',
        help='overwrite the file if it exists on the remote host',
        action='store_true', default=False)
    (options, args) = parser.parse_args()

    cmd_def = ''.join(['\t%s: %s\n' % (
        cmd, CMD_DEF[cmd][DESCRIPTION]) for cmd in CMD_DEF.keys()])

    if len(args) < 1:
        sys.stderr.write(
            'Command argument is required. Available commands are:\n' + cmd_def)
        sys.exit(1)
    elif args[0] not in CMD_DEF.keys(): 
        sys.stderr.write(
            'Invalid command %s. Available commands are:\n%s' % (
                args[0], cmd_def))
        sys.exit(1)
    elif len(args) - 1 != len(CMD_DEF[args[0]][PARAMETERS]):
        sys.stderr.write(
            'Invalid number of parameters for command %s.' % args[0] +
            ' Required parameters are:\n' +
            ''.join('\t%s\n' % param for param in CMD_DEF[args[0]][PARAMETERS]))
        sys.exit(1)
    else:
        cmd = args[0]
        params = dict(zip(args[1:], CMD_DEF[args[0]][PARAMETERS]))
        params.update(vars(options))
        try:
            (code, msg) = main(cmd, params)
        except Exception as exc:
            sys.stderr.write('%s\n' % str(exc))
            sys.exit(1)
        else:
            sys.stdout.write('%s\n' % msg)
            try:
                code_int = int(code)
            except ValueError:
                sys.stderr.write(
                    'Invalid response from the server: %s %s' % (code, msg))
                sys.exit(1)

