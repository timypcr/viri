#!/usr/bin/env python3
import sys
import os
import logging
import multiprocessing
import resource
from optparse import OptionParser
from configparser import RawConfigParser
from viri.scriptmanager import ScriptManager
from viri.rpcserver import RPCServer
from viri.schedserver import SchedServer

APP_NAME = 'virid'
APP_VERSION = '0.0.1'
APP_DESC = 'Receives and executes scripts from viric instances'
LOG_LEVELS = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')
SCRIPT_DIR = 'script'
INFO_DIR = 'info'
DATA_DIR = 'data'
DEFAULT_CONFIG_FILE = '/etc/viri/virid.conf'
DEFAULTS = {
    'General': {
        'Port': '6806'},
    'Paths': {
        'KnownCAs': '/etc/viri/ca.cert',
        'CertKeyFile': '/etc/viri/virid.pem',
        'WorkingDir': '/var/viri'},
    'Logging': {
        'LogFile': '/var/log/virid.log',
        'LogLevel': 'WARNING',
        'LogFormat': '%(levelname)s::%(asctime)s::%(message)s'},
}

class ViriDaemon:
    def __init__(self, config_file):
        self.config_file = config_file
        self._setup()

    def _daemonize(self):
        """Deatach the process from the controlling terminal and run in the
        background as a daemon.

        Based on:
            http://code.activestate.com/recipes/
                278731-creating-a-daemon-the-python-way/
        """
        # double fork
        if os.fork() != 0:
            os._exit(0)
        else:
            os.setsid()
            if os.fork() != 0:
                os._exit(0)
            else:
                os.chdir(os.path.expanduser('~'))
                os.umask(0)

        maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
        maxfd = 1024 if maxfd == resource.RLIM_INFINITY else maxfd
        for fd in range(0, maxfd):
            try:
                os.close(fd)
            except OSError:
                pass
        os.open(os.devnull, os.O_RDWR)
        os.dup2(0, 1)
        os.dup2(0, 2)

    def _prepare_dirs(self):
        """Creates the structure for the working directory, which
        contains directories for data, tasks, and a system directory
        which is used to store files like the base task or the crontab
        file. It also creates required __init__.py files.
        """
        create_dirs = (self.working_dir,
            self.script_dir,
            self.info_dir,
            self.data_dir)

        for create_dir in create_dirs:
            if not os.path.isdir(create_dir):
                os.mkdir(create_dir)

        init_filename = os.path.join(self.script_dir, '__init__.py')
        if not os.path.isfile(init_filename):
            open(init_filename, 'w').close()

        if self.script_dir not in sys.path:
            sys.path.append(self.script_dir)

    def _setup(self):
        """Initializes all required attributes, getting the values from the
        configuration file.
        """
        config = RawConfigParser(DEFAULTS)
        config.read((self.config_file,))

        self.port = int(config.get('General', 'Port'))
        self.ca_file = config.get('Paths', 'KnownCAs')
        self.cert_key_file = config.get('Paths', 'CertKeyFile')
        self.working_dir = config.get('Paths', 'WorkingDir')
        self.logfile = config.get('Logging', 'LogFile')
        self.loglevel = config.get('Logging', 'LogLevel')
        self.logformat = config.get('Logging', 'LogFormat')

        if not os.path.isfile(self.ca_file):
            raise ValueError('Known CAs file not found: %s' % self.ca_file)
        if not os.path.isfile(self.cert_key_file):
            raise ValueError('Certificate and key file not found: %s' %
                self.cert_key_file)

        conf = None
        if config.has_section('Custom'):
            Conf = type('Conf', tuple(), {})
            conf = Conf()
            for key, val in dict(config.items('Custom')).items():
                if key not in DEFAULTS.keys():
                    setattr(conf, key, val)

        self.script_dir = os.path.abspath(
            os.path.join(self.working_dir, SCRIPT_DIR))
        self.info_dir = os.path.abspath(
            os.path.join(self.working_dir, INFO_DIR))
        self.data_dir = os.path.abspath(
            os.path.join(self.working_dir, DATA_DIR))

        self.context = {}
        self.context['conf'] = conf
        self.context['data_dir'] = self.data_dir

        self.script_manager = ScriptManager(
            self.script_dir, self.info_dir, self.context)

        self._prepare_dirs()

        logging.basicConfig(
            filename=self.logfile,
            format=self.logformat,
            level=getattr(logging, self.loglevel))

    def start(self):
        """Starts the ViriDaemon. This daemonizes the process, gets required
        settings from config file, and starts both the SchedServer for task
        scheduling, and the RPCServer to accept connections form viric instances
        """
        logging.info('Starting daemon...')
        self._daemonize()
        self.sched_server = SchedServer(
            self.data_dir, self.context)
        self.sched_server_proc = multiprocessing.Process(
            target=self.sched_server.start)
        self.sched_server_proc.start()

        self.rpc_server = RPCServer(
            self.port,
            self.ca_file,
            self.cert_key_file,
            self.script_dir,
            self.data_dir,
            self.script_manager)
        self.rpc_server.start()
        logging.info('Daemon started on port %s' % self.port)

    def stop(self):
        logging.info('Stopping daemon...')
        self.sched_server_proc.join()
        logging.info('Daemon stopped')

if __name__ == '__main__':
    parser = OptionParser(
        description=APP_DESC,
        version=APP_VERSION)
    parser.add_option('-c', '--config', dest='config_file',
        help='configuration file with settings to be used by virid',
        default=DEFAULT_CONFIG_FILE)
    (options, args) = parser.parse_args()

    try:
        virid = ViriDaemon(**vars(options))
    except Exception as exc:
        sys.stderr.write('%s\n' % exc)
        logging.critical('%s\n' % exc)
        sys.exit(1)

    try:
        virid.start()
    except KeyboardInterrupt:
        virid.stop()

