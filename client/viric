#!/usr/bin/env python

# Copyright 2011, Marc Garcia <garcia.marc@gmail.com>
#
# This file is part of Viri.
#
# Viri is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# Viri is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Viri.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import socket
import ssl
from hashlib import sha1
from optparse import OptionParser

if sys.version_info[0] == 2:
    import httplib as http_client
    import xmlrpclib as xmlrpc_client
else:
    from http import client as http_client
    from xmlrpc import client as xmlrpc_client

APP_DESC = 'Remote execution of Python scripts'
APP_VERSION = '0.1'
DEFAULT_PORT = 6808
PROTOCOL = ssl.PROTOCOL_TLSv1
DATE_FORMAT = '%Y-%m-%d %H-%M'
SUCCESS = True
ERROR = False


class ConfError(Exception):
    """Represents a error in user provided configuration"""


class HTTPConnectionTLS(http_client.HTTPSConnection):
    """Extending http.client.HTTPSConnection class, so we can specify which
    protocol we want to use (we'll use TLS instead SSL)
    """
    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if self._tunnel_host:
            self.sock = sock
            self._tunnel()
        self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
            ssl_version=PROTOCOL)


class TransportTLS(xmlrpc_client.Transport, object):
    """Extending xmlrpc.client.Transport class, so we can specify client
    certificates needed for client authentication.
    """
    def __init__(self, key_file, cert_file, *args, **kwargs):
        self.key_file = key_file
        self.cert_file = cert_file
        super(TransportTLS, self).__init__(*args, **kwargs)

    def request(self, host, handler, request_body, verbose=False):
        host, extra_headers, x509 = self.get_host_info(host)
        http_conn = HTTPConnectionTLS(
            host,
            None,
            self.key_file,
            self.cert_file,
            **(x509 or {}))
        headers = {}
        if extra_headers:
            for key, val in extra_headers:
                headers[key] = val
        headers['Content-Type'] = 'text/xml'
        headers['User-Agent'] = self.user_agent
        http_conn.request('POST', handler, request_body, headers)
        resp = http_conn.getresponse()

        if resp.status != 200:
            raise xmlrpc_client.ProtocolError(
                host + handler,
                resp.status, resp.reason,
                dict(resp.getheaders())
                )

        self.verbose = verbose
        return self.parse_response(resp)


class Command(object):
    def __init__(self, keyfile, certfile):
        self.keyfile = keyfile
        self.certfile = certfile

    def connect(self, host):
        if ':' not in host: host += ':' + str(DEFAULT_PORT)
        self.server = xmlrpc_client.ServerProxy(
            'https://{0}/'.format(host),
            transport=TransportTLS(
                self.keyfile,
                self.certfile,
                use_datetime=True),
            allow_none=True)

    def format(self, success, value):
        return value


class Execute(Command):
    def run(self, filename_or_id, *args):
        return self.server.execute({
            'file_name_or_id': filename_or_id,
            'args': args})


class Put(Command):
    def run(self, filename):
        with open(filename, 'rb') as f:
            content = f.read()
        file_id = sha1(content).hexdigest()
        success, value = self.server.exists({'file_id': file_id})
        if success:
            if not value:
                return self.server.put({
                    'file_name': os.path.basename(filename),
                    'file_content': xmlrpc_client.Binary(content),
                })
            else:
                return (SUCCESS, 'File exists with name {0}'.format(value))
        else:
            return (success, value)


class PutExec(Command):
    def run(self, filename, args=()):
        with open(filename, 'rb') as f:
            content = f.read()
        file_id = sha1(content).hexdigest()
        success, exists_value = self.server.exists({'file_id': file_id})
        if success:
            if not exists_value:
                print('sending')
                success, put_value = self.server.put({
                    'file_name': os.path.basename(filename),
                    'file_content': xmlrpc_client.Binary(content),
                })
            if success:
                success, exec_value = self.server.execute({
                    'file_name_or_id': file_id,
                    'args': args})
                return (success, '\n'.join([file_id, exec_value]))
            else:
                return (success, put_value)
        else:
            return (success, exists_value)


class Get(Command):
    def format(self, success, value):
        return value.data if success else value

    def run(self, filename_or_id):
        return self.server.get({
            'file_name_or_id': filename_or_id})


class Ls(Command):
    def format(self, success, value):
        if success:
            res = ''
            for row in value:
                res += '\t'.join([
                    row['saved'].strftime(DATE_FORMAT),
                    row['file_id'],
                    row['file_name']]) + os.linesep
            return res
        else:
            return value

    def run(self):
        return self.server.ls({})


class Mv(Command):
    def run(self, file_id, new_file_name):
        return self.server.mv({
            'file_id': file_id,
            'new_file_name': new_file_name})


class Rm(Command):
    def run(self, *file_id_list):
        cnt_ok = 0
        cnt_err = 0
        for file_id in file_id_list:
            success, value = self.server.rm({
                'file_id': file_id})
            if success: cnt_ok += 1
            else: cnt_err += 1
        if not cnt_err:
            return (True, '{0} file(s) successfully removed'.format(cnt_ok))
        else:
            return (False, '{0} file(s) successfully removed\n'.format(cnt_ok) +
                '{0} files not found'.format(cnt_err))


if __name__ == '__main__':
    CMD_MAP = {
        'exec': Execute,
        'put': Put,
        'put-exec': PutExec,
        'get': Get,
        'ls': Ls,
        'mv': Mv,
        'rm': Rm,
    }
    parser = OptionParser(
        'Usage: %prog command [OPTIONS]',
        description=APP_DESC,
        version=APP_VERSION)
    parser.add_option('-H', '--hosts', dest='hosts',
        default='localhost', help='destination host')
    parser.add_option('-k', '--keyfile', dest='keyfile', default=None,
        help='TLS key (only if it is not included on the TLS certificate)')
    parser.add_option('-c', '--certfile', dest='certfile',
        default=os.path.expanduser('~/.viri/viric.pem'),
        help='TLS certificate')
    options, args = parser.parse_args()

    if not args:
        sys.stderr.write('viric: command argument missing\n')
        sys.exit(1)
    elif args[0] in CMD_MAP.keys():
        # TODO verify if certificates exist and look valid, and raise
        # useful message to user if not
        cmd = CMD_MAP[args[0]](options.keyfile, options.certfile)
        hosts = options.hosts.split(',')
        for host in hosts:
            cmd.connect(host)
            success, value = cmd.run(*args[1:])
            if len(hosts) > 1:
                print('Executed on host {0} returned {1}. Response:'.format(
                    host.split(':')[0],
                    'SUCCESS' if success else 'ERROR'))
            print(cmd.format(success, value))
            print('')
        sys.exit(0)
    else:
        sys.stderr.write('viric: unknown command {0}\n'.format(args[0]))
        sys.exit(1)

